{"version":3,"sources":["/Users/christoph/repos/own/webpack-license-plugin/dist/index.js","WebpackLicensePlugin.ts","LicenseFileWriter.ts","LicenseIdentifier.ts","LicenseTextReader.ts","DefaultLicenseTextProvider.ts","NoticeTextReader.ts","LicenseMetaAggregator.ts","ModuleDirectoryLocator.ts","OptionsProvider.ts","defaultOptions.ts","PackageJsonReader.ts","WebpackAlertAggregator.ts","WebpackAssetManager.ts","WebpackChunkModuleIterator.ts","WebpackModuleFileIterator.ts","WebpackChunkIterator.ts","WebpackFileSystem.ts","index.ts"],"names":["Y","Object","defineProperty","te","c","e","t","enumerable","configurable","writable","value","n","i","webpack","lodash","compact","uniq","LicenseFileWriter","assetManager","moduleDirectoryLocator","licenseMetaAggregator","writeLicenseFiles","filenames","options","moduleDirs","includePackages","licenseMeta","fileContents","filename","result","getModuleDirs","aggregateMeta","Set","JSON","stringify","addFile","outputFilename","keys","additionalFiles","map","getModuleDir","_LicenseFileWriter","validate","LicenseIdentifier","alertAggregator","preferredLicenses","identifyLicense","meta","id","name","version","license","licenseOverrides","type","Array","isArray","licenses","length","findPreferredLicense","l","unacceptableLicenseTest","addError","licenseTypes","preferredLicenseType","licenseType","_LicenseIdentifier","join","needle","fetch","url","res","statusCode","body","REPO_URL","DefaultLicenseTextProvider","request","cache","retrieveLicenseText","_DefaultLicenseTextProvider","LicenseTextReader","fileSystem","defaultLicenseReader","readLicenseText","moduleDir","pathsInModuleDir","licenseFilename","indexOf","split","readFile","listPaths","getLicenseFilename","replenishDefaultLicenseTexts","getDefaultLicenseText","paths","path","test","directory","replace","_LicenseTextReader","NoticeTextReader","readNoticeText","noticeFilename","noticeFilePath","find","_NoticeTextReader","LicenseMetaAggregator","packageJsonReader","licenseIdentifier","licenseTextReader","noticeTextReader","getNpmTarballUrl","pkgName","pkgVersion","scopelessName","plusPos","substring","packageSet","sortedModuleDirs","packageIdentifier","licenseText","noticeText","sort","a","b","readPackageJson","localeCompare","has","excludedPackageTest","add","includeNoticeText","undefined","push","author","getAuthor","repository","getRepository","source","email","_LicenseMetaAggregator","resolve","sep","ModuleDirectoryLocator","buildRoot","lastIndexOf","checkModuleDir","dirWithVersion","dirWithLicense","prevModuleDir","pathExists","packageMeta","_ModuleDirectoryLocator","defaultOptions","__name","defaultOptions_default","OptionsProvider","getOptions","inputOptions","validateOptions","fileName","packageVersion","_OptionsProvider","PackageJsonReader","parse","_PackageJsonReader","WebpackError","WebpackAlertAggregator","compilation","errors","warnings","message","addWarning","flushAlerts","prefix","w","_WebpackAlertAggregator","sources","WebpackAssetManager","contents","assets","RawSource","_WebpackAssetManager","WebpackChunkModuleIterator","iterateModules","chunk","callback","chunkGraph","getChunkModulesIterable","module","modulesIterable","forEachModule","modules","forEach","getChunkEntryModulesIterable","entryModule","_WebpackChunkModuleIterator","WebpackModuleFileIterator","iterateFiles","resource","rootModule","fileDependencies","dependencies","dep","originModule","_parentModule","_WebpackModuleFileIterator","WebpackChunkIterator","moduleIterator","fileIterator","iterateChunks","chunks","_WebpackChunkIterator","WebpackFileSystem","fs","statSync","readFileSync","toString","dir","readdirSync","_WebpackFileSystem","pluginName","WebpackLicensePlugin","pluginOptions","createdFiles","observedCompilers","apply","compiler","hooks","tap","handleCompilation","bind","watchRun","tapAsync","handleWatchRun","plugin","_","processAssets","boundHandleChunkAssetOptimization","handleChunkAssetOptimization","stage","Compilation","PROCESS_ASSETS_STAGE_ANALYSE","optimizeChunkAssets","observedCompilersMessage","errorMessage","chunkIterator","isChild","inputFileSystem","context","_WebpackLicensePlugin","index_default"],"mappings":"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","sourcesContent":["var Y=Object.defineProperty;var te=(c,e,t)=>e in c?Y(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var n=(c,e)=>Y(c,\"name\",{value:e,configurable:!0});var i=(c,e,t)=>te(c,typeof e!=\"symbol\"?e+\"\":e,t);import Q from\"webpack\";import se from\"lodash\";var{compact:ie,uniq:re}=se,R=class R{constructor(e,t,s){i(this,\"assetManager\");i(this,\"moduleDirectoryLocator\");i(this,\"licenseMetaAggregator\");this.assetManager=e,this.moduleDirectoryLocator=t,this.licenseMetaAggregator=s}async writeLicenseFiles(e,t){let s=this.getModuleDirs(e),r=await t.includePackages(),o=await this.licenseMetaAggregator.aggregateMeta([...new Set([...s,...r])]),a=JSON.stringify(o,null,2);this.assetManager.addFile(t.outputFilename,a);for(let l of Object.keys(t.additionalFiles)){let d=await t.additionalFiles[l](o);this.assetManager.addFile(l,d)}}getModuleDirs(e){return re(ie(e.map(t=>this.moduleDirectoryLocator.getModuleDir(t))))}};n(R,\"LicenseFileWriter\");var u=R;import ne from\"spdx-expression-validate\";var P=class P{constructor(e,t=[]){i(this,\"alertAggregator\");i(this,\"preferredLicenses\");this.alertAggregator=e,this.preferredLicenses=t}identifyLicense(e,t){let s=`${e.name}@${e.version}`,r;return t.licenseOverrides[s]?r=t.licenseOverrides[s]:typeof e.license==\"object\"?r=e.license.type:e.license?r=e.license:Array.isArray(e.licenses)&&e.licenses.length>0?r=this.findPreferredLicense(e.licenses.map(o=>o.type))||e.licenses[0].type:typeof e.licenses==\"string\"&&(r=e.licenses),r?t.unacceptableLicenseTest(r)?this.alertAggregator.addError(`Found unacceptable license \"${r}\" for ${s}`):ne(r)||this.alertAggregator.addError(`License \"${r}\" for ${s} is not a valid SPDX expression!`):this.alertAggregator.addError(`Could not find license info for ${s}`),r||null}findPreferredLicense(e){for(let t of this.preferredLicenses)for(let s of e)if(t===s)return t;return null}};n(P,\"LicenseIdentifier\");var p=P;import{join as ce}from\"node:path\";import oe from\"needle\";async function ae(c){let e=await oe(\"get\",c);return e.statusCode===200?e.body:null}n(ae,\"fetch\");var le=\"https://raw.githubusercontent.com/spdx/license-list-data\",M=class M{constructor(e=ae){i(this,\"request\");i(this,\"cache\");this.request=e,this.cache={}}async retrieveLicenseText(e){if(!this.cache[e]){let t=await this.request(`${le}/main/text/${e}.txt`);this.cache[e]=t}return this.cache[e]||null}};n(M,\"DefaultLicenseTextProvider\");var g=M;var I=class I{constructor(e,t,s,r=new g){i(this,\"alertAggregator\");i(this,\"fileSystem\");i(this,\"options\");i(this,\"defaultLicenseReader\");this.alertAggregator=e,this.fileSystem=t,this.options=s,this.defaultLicenseReader=r}async readLicenseText(e,t,s){let r=`${e.name}@${e.version}`;if(!t)return null;if(t.indexOf(\"SEE LICENSE IN \")===0){let l=t.split(\" \")[3];try{return this.readFile(s,l)}catch{this.alertAggregator.addError(`could not find file specified in package.json license field of ${r}`)}}let o=this.fileSystem.listPaths(s),a=this.getLicenseFilename(o);return a!==null?this.readFile(s,a):this.options.replenishDefaultLicenseTexts?await this.getDefaultLicenseText(t):null}getLicenseFilename(e){for(let t of e)if(/^licen[cs]e/i.test(t))return t;return null}readFile(e,t){return this.fileSystem.readFile(ce(e,t)).replace(/\\r\\n/g,`\n`)}async getDefaultLicenseText(e){return await this.defaultLicenseReader.retrieveLicenseText(e)}};n(I,\"LicenseTextReader\");var m=I;import{join as de}from\"node:path\";var O=class O{constructor(e){i(this,\"fileSystem\");this.fileSystem=e}async readNoticeText(e){let t=this.fileSystem.listPaths(e).find(r=>/^notice/i.test(r));if(!t)return null;let s=de(e,t);return this.fileSystem.readFile(s).replace(/\\r\\n/g,`\n`)}};n(O,\"NoticeTextReader\");var y=O;var J=class J{constructor(e,t,s,r,o=new p(t),a=new m(t,e,s),l=new y(e)){i(this,\"options\");i(this,\"packageJsonReader\");i(this,\"licenseIdentifier\");i(this,\"licenseTextReader\");i(this,\"noticeTextReader\");this.options=s,this.packageJsonReader=r,this.licenseIdentifier=o,this.licenseTextReader=a,this.noticeTextReader=l}getNpmTarballUrl(e,t){let s=e[0]!==\"@\"?e:e.split(\"/\")[1],r=t.indexOf(\"+\"),o=r===-1?t:t.substring(0,r);return`https://registry.npmjs.org/${e}/-/${s}-${o}.tgz`}async aggregateMeta(e){let t=new Set,s=[],r=e.sort((o,a)=>this.packageJsonReader.readPackageJson(o).name.localeCompare(this.packageJsonReader.readPackageJson(a).name));for(let o of r){let a=this.packageJsonReader.readPackageJson(o),l=`${a.name}@${a.version}`;if(t.has(l)||this.options.excludedPackageTest(a.name,a.version))continue;t.add(l);let d=this.licenseIdentifier.identifyLicense(a,this.options),f=await this.licenseTextReader.readLicenseText(a,d,o),h=this.options.includeNoticeText?await this.noticeTextReader.readNoticeText(o):void 0;s.push({name:a.name,version:a.version,author:this.getAuthor(a),repository:this.getRepository(a),source:this.getNpmTarballUrl(a.name,a.version),license:d,licenseText:f,...h?{noticeText:h}:{}})}return s}getAuthor(e){return typeof e.author==\"object\"?`${e.author.name}${e.author.email?` <${e.author.email}>`:\"\"}${e.author.url?` (${e.author.url})`:\"\"}`:e.author}getRepository(e){return e.repository&&e.repository.url?e.repository.url:typeof e.repository==\"string\"?e.repository:null}};n(J,\"LicenseMetaAggregator\");var w=J;import{resolve as fe,sep as T}from\"node:path\";var j=class j{constructor(e,t,s){i(this,\"fileSystem\");i(this,\"buildRoot\");i(this,\"packageJsonReader\");this.fileSystem=e,this.buildRoot=t,this.packageJsonReader=s}getModuleDir(e){let t=e.substring(0,e.lastIndexOf(T));return this.checkModuleDir(t)}checkModuleDir(e){let t=null,s=null,r=null;do{if(this.fileSystem.pathExists(`${e}${T}package.json`)){let o=this.packageJsonReader.readPackageJson(e);o.name!==void 0&&o.version!==void 0&&(t=e,(o.license!==void 0||o.licenses!==void 0)&&(s=e))}r=e,e=fe(`${e}${T}..${T}`)}while(!s&&e!==r&&e!==this.buildRoot);return s||t}};n(j,\"ModuleDirectoryLocator\");var x=j;import ue from\"spdx-expression-validate\";var he={additionalFiles:{},licenseOverrides:{},outputFilename:\"oss-licenses.json\",replenishDefaultLicenseTexts:!1,includeNoticeText:!1,unacceptableLicenseTest:n(()=>!1,\"unacceptableLicenseTest\"),excludedPackageTest:n(()=>!1,\"excludedPackageTest\"),includePackages:n(()=>[],\"includePackages\")},B=he;var N=class N{constructor(e){i(this,\"alertAggregator\");this.alertAggregator=e}getOptions(e){return this.validateOptions(e),{...B,...e}}validateOptions(e){if(e.additionalFiles)for(let t of Object.keys(e.additionalFiles))typeof e.additionalFiles[t]!=\"function\"&&this.alertAggregator.addError(`Invalid additionalFiles option: Value for key \"${t}\" is not a function!`);if(e.licenseOverrides)for(let t of Object.keys(e.licenseOverrides))ue(e.licenseOverrides[t])||this.alertAggregator.addError(`Invalid licenseOverrides option: \"${e.licenseOverrides[t]}\" is not a valid SPDX expression!`);e.replenishDefaultLicenseTexts&&typeof e.replenishDefaultLicenseTexts!=\"boolean\"&&this.alertAggregator.addError(\"Invalid replenishDefaultLicenseTexts option: Not a boolean!\"),e.includePackages&&typeof e.includePackages!=\"function\"&&this.alertAggregator.addError(\"Invalid includePackages option: Not a function!\")}};n(N,\"OptionsProvider\");var k=N;import{join as pe}from\"node:path\";var z=class z{constructor(e){i(this,\"fileSystem\");i(this,\"cache\");this.fileSystem=e,this.cache={}}readPackageJson(e){if(!this.cache[e]){let t=pe(e,\"package.json\"),s=JSON.parse(this.fileSystem.readFile(t));this.cache[e]=s}return this.cache[e]}};n(z,\"PackageJsonReader\");var v=z;import ge from\"webpack\";var K=ge.WebpackError,D=class D{constructor(e){i(this,\"compilation\");i(this,\"errors\");i(this,\"warnings\");this.compilation=e,this.errors=[],this.warnings=[]}addError(e){this.errors.push(e)}addWarning(e){this.warnings.push(e)}flushAlerts(e){this.compilation.errors.push(...this.errors.map(t=>new K(`${e}: ${t}`))),this.errors=[],this.compilation.warnings.push(...this.warnings.map(t=>new K(`${e}: ${t}`))),this.warnings=[]}};n(D,\"WebpackAlertAggregator\");var A=D;import me from\"webpack\";var ye=me.sources,G=class G{constructor(e){i(this,\"compilation\");this.compilation=e}addFile(e,t){this.compilation.assets[e]=new ye.RawSource(t)}};n(G,\"WebpackAssetManager\");var $=G;var W=class W{iterateModules(e,t,s){if(typeof e.chunkGraph<\"u\")for(let r of e.chunkGraph.getChunkModulesIterable(t))s(r);else if(typeof t.modulesIterable<\"u\")for(let r of t.modulesIterable)s(r);else typeof t.forEachModule==\"function\"?t.forEachModule(s):Array.isArray(t.modules)&&t.modules.forEach(r=>s(r));if(typeof e.chunkGraph<\"u\")for(let r of e.chunkGraph.getChunkEntryModulesIterable(t))s(r);else t.entryModule&&s(t.entryModule)}};n(W,\"WebpackChunkModuleIterator\");var F=W;var q=class q{iterateFiles({resource:e,rootModule:t,fileDependencies:s,dependencies:r},o){e?o(e):t?.resource&&o(t.resource),s&&s.forEach(a=>o(a)),r&&r.forEach(({originModule:a,_parentModule:l})=>{a?.resource&&o(a.resource),l?.resource&&o(l.resource)})}};n(q,\"WebpackModuleFileIterator\");var S=q;var U=class U{constructor(e=new F,t=new S){i(this,\"moduleIterator\");i(this,\"fileIterator\");this.moduleIterator=e,this.fileIterator=t}iterateChunks(e,t){let s=[];for(let r of t)this.moduleIterator.iterateModules(e,r,o=>{this.fileIterator.iterateFiles(o,a=>{s.push(a)})});return s}};n(U,\"WebpackChunkIterator\");var b=U;var X=class X{constructor(e){i(this,\"fs\");this.fs=e}pathExists(e){try{return this.fs.statSync(e),!0}catch{return!1}}readFile(e){return this.fs.readFileSync(e).toString(\"utf8\")}listPaths(e){return this.fs.readdirSync(e)}};n(X,\"WebpackFileSystem\");var E=X;var we=Q.WebpackError,H=\"WebpackLicensePlugin\",V=class V{constructor(e={}){i(this,\"pluginOptions\");i(this,\"filenames\");i(this,\"createdFiles\");i(this,\"observedCompilers\");this.pluginOptions=e,this.filenames=new Set,this.createdFiles=!1,this.observedCompilers=[]}apply(e){typeof e.hooks<\"u\"?(e.hooks.compilation.tap(\"webpack-license-plugin\",this.handleCompilation.bind(this,e)),e.hooks.watchRun.tapAsync(\"webpack-license-plugin\",this.handleWatchRun.bind(this))):typeof e.plugin<\"u\"&&(e.plugin(\"compilation\",this.handleCompilation.bind(this,e)),e.plugin(\"watchRun\",this.handleWatchRun.bind(this)))}async handleWatchRun(e,t){this.createdFiles=!1,this.observedCompilers=[],t()}handleCompilation(e,t){if(typeof t.hooks<\"u\")if(typeof t.hooks.processAssets<\"u\"){let s=this.handleChunkAssetOptimization.bind(this,e,t,t.chunks);t.hooks.processAssets.tapAsync({name:\"webpack-license-plugin\",stage:Q.Compilation.PROCESS_ASSETS_STAGE_ANALYSE},(r,o)=>s(o))}else t.hooks.optimizeChunkAssets.tapAsync(\"webpack-license-plugin\",this.handleChunkAssetOptimization.bind(this,e,t));else typeof t.plugin<\"u\"&&t.plugin(\"optimize-chunk-assets\",this.handleChunkAssetOptimization.bind(this,e,t))}async handleChunkAssetOptimization(e,t,s,r){if(this.observedCompilers.push({name:t.compiler.name,isChild:t.compiler.isChild()}),this.createdFiles){let C=this.observedCompilers.map(({name:_,isChild:ee})=>`compiler: ${_}, isChild: ${ee}`).join(`\n`),Z=new we(`${H}: Found licenses after license files were already created.\nIf you see this message, you ran into an edge case we thought would not happen. Please open an isssue at https://github.com/codepunkt/webpack-license-plugin/issues with details of your webpack configuration so we can invastigate it further.\n${C}`);t.errors.push(Z),r();return}t.compiler.isChild()||(this.createdFiles=!0);let o=new A(t),l=new k(o).getOptions(this.pluginOptions);o.flushAlerts(H);let d=new b;for(let C of d.iterateChunks(t,s))this.filenames.add(C);if(t.compiler.isChild()){r();return}let f=new E(e.inputFileSystem),h=new v(f);await new u(new $(t),new x(f,e.options.context,h),new w(f,o,l,h)).writeLicenseFiles([...this.filenames],l),o.flushAlerts(H),r()}};n(V,\"WebpackLicensePlugin\");var L=V;var Tt=L;export{Tt as default};\n","import type { Chunk, Compilation, Compiler } from 'webpack'\nimport type IPluginOptions from './types/IPluginOptions'\nimport type IWebpackPlugin from './types/IWebpackPlugin'\nimport webpack from 'webpack'\nimport LicenseFileWriter from './LicenseFileWriter'\nimport LicenseMetaAggregator from './LicenseMetaAggregator'\nimport ModuleDirectoryLocator from './ModuleDirectoryLocator'\nimport OptionsProvider from './OptionsProvider'\nimport PackageJsonReader from './PackageJsonReader'\nimport WebpackAlertAggregator from './WebpackAlertAggregator'\nimport WebpackAssetManager from './WebpackAssetManager'\nimport WebpackChunkIterator from './WebpackChunkIterator'\nimport WebpackFileSystem from './WebpackFileSystem'\n\nconst WebpackError = webpack.WebpackError\nconst pluginName = 'WebpackLicensePlugin'\n\ninterface ObservedCompiler {\n  name: string\n  isChild: boolean\n}\n\nexport default class WebpackLicensePlugin implements IWebpackPlugin {\n  private readonly filenames = new Set<string>()\n  private createdFiles = false\n  private observedCompilers: ObservedCompiler[] = []\n\n  constructor(private pluginOptions: Partial<IPluginOptions> = {}) {}\n\n  public apply(compiler: Compiler) {\n    if (typeof compiler.hooks !== 'undefined') {\n      compiler.hooks.compilation.tap(\n        'webpack-license-plugin',\n        this.handleCompilation.bind(this, compiler),\n      )\n      compiler.hooks.watchRun.tapAsync(\n        'webpack-license-plugin',\n        this.handleWatchRun.bind(this),\n      )\n    }\n    // @ts-expect-error plugin doesn't exist on compiler\n    else if (typeof compiler.plugin !== 'undefined') {\n      // @ts-expect-error plugin doesn't exist on compiler\n      compiler.plugin(\n        'compilation',\n        this.handleCompilation.bind(this, compiler),\n      )\n      // @ts-expect-error plugin doesn't exist on compiler\n      compiler.plugin('watchRun', this.handleWatchRun.bind(this))\n    }\n  }\n\n  public async handleWatchRun(_: unknown, callback: () => void) {\n    this.createdFiles = false\n    this.observedCompilers = []\n    callback()\n  }\n\n  public handleCompilation(compiler: Compiler, compilation: Compilation) {\n    if (typeof compilation.hooks !== 'undefined') {\n      if (typeof compilation.hooks.processAssets !== 'undefined') {\n        const boundHandleChunkAssetOptimization\n          = this.handleChunkAssetOptimization.bind(\n            this,\n            compiler,\n            compilation,\n            compilation.chunks,\n          )\n\n        compilation.hooks.processAssets.tapAsync(\n          {\n            name: 'webpack-license-plugin',\n            stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ANALYSE,\n          },\n          (assets, callback) => boundHandleChunkAssetOptimization(callback),\n        )\n      }\n      else {\n        compilation.hooks.optimizeChunkAssets.tapAsync(\n          'webpack-license-plugin',\n          this.handleChunkAssetOptimization.bind(this, compiler, compilation),\n        )\n      }\n    }\n    // @ts-expect-error plugin doesn't exist on compilation\n    else if (typeof compilation.plugin !== 'undefined') {\n      // @ts-expect-error plugin doesn't exist on compilation\n      compilation.plugin(\n        'optimize-chunk-assets',\n        this.handleChunkAssetOptimization.bind(this, compiler, compilation),\n      )\n    }\n  }\n\n  public async handleChunkAssetOptimization(\n    compiler: Compiler,\n    compilation: Compilation,\n    chunks: Set<Chunk>,\n    callback: () => void,\n  ) {\n    this.observedCompilers.push({\n      name: compilation.compiler.name,\n      isChild: compilation.compiler.isChild(),\n    })\n\n    if (this.createdFiles) {\n      const observedCompilersMessage = this.observedCompilers\n        .map(({ name, isChild }) => `compiler: ${name}, isChild: ${isChild}`)\n        .join('\\n')\n      const errorMessage = new WebpackError(\n        `${pluginName}: Found licenses after license files were already created.\\nIf you see this message, you ran into an edge case we thought would not happen. Please open an isssue at https://github.com/codepunkt/webpack-license-plugin/issues with details of your webpack configuration so we can invastigate it further.\\n${observedCompilersMessage}`,\n      )\n      compilation.errors.push(errorMessage)\n      callback()\n      return\n    }\n\n    if (!compilation.compiler.isChild()) {\n      this.createdFiles = true\n    }\n\n    const alertAggregator = new WebpackAlertAggregator(compilation)\n    const optionsProvider = new OptionsProvider(alertAggregator)\n\n    const options = optionsProvider.getOptions(this.pluginOptions)\n    alertAggregator.flushAlerts(pluginName)\n\n    const chunkIterator = new WebpackChunkIterator()\n    for (const filename of chunkIterator.iterateChunks(compilation, chunks)) {\n      this.filenames.add(filename)\n    }\n\n    if (compilation.compiler.isChild()) {\n      callback()\n      return\n    }\n\n    const fileSystem = new WebpackFileSystem(compiler.inputFileSystem)\n    const packageJsonReader = new PackageJsonReader(fileSystem)\n    const licenseFileWriter = new LicenseFileWriter(\n      new WebpackAssetManager(compilation),\n      new ModuleDirectoryLocator(\n        fileSystem,\n        compiler.options.context,\n        packageJsonReader,\n      ),\n      new LicenseMetaAggregator(\n        fileSystem,\n        alertAggregator,\n        options,\n        packageJsonReader,\n      ),\n    )\n\n    await licenseFileWriter.writeLicenseFiles([...this.filenames], options)\n    alertAggregator.flushAlerts(pluginName)\n\n    callback()\n  }\n}\n","import type IAssetManager from './types/IAssetManager'\nimport type ILicenseMetaAggregator from './types/ILicenseMetaAggregator'\nimport type IModuleDirectoryLocator from './types/IModuleDirectoryLocator'\nimport type IPluginOptions from './types/IPluginOptions'\nimport lodash from 'lodash'\n\nconst { compact, uniq } = lodash\n\nexport default class LicenseFileWriter {\n  constructor(\n    private assetManager: IAssetManager,\n    private moduleDirectoryLocator: IModuleDirectoryLocator,\n    private licenseMetaAggregator: ILicenseMetaAggregator,\n  ) {}\n\n  public async writeLicenseFiles(\n    filenames: string[],\n    options: IPluginOptions,\n  ): Promise<void> {\n    const moduleDirs = this.getModuleDirs(filenames)\n    const includePackages = await options.includePackages()\n    const licenseMeta = await this.licenseMetaAggregator.aggregateMeta([\n      ...new Set([...moduleDirs, ...includePackages]),\n    ])\n\n    const fileContents = JSON.stringify(licenseMeta, null, 2)\n    this.assetManager.addFile(options.outputFilename, fileContents)\n\n    for (const filename of Object.keys(options.additionalFiles)) {\n      const result = await options.additionalFiles[filename](licenseMeta)\n      this.assetManager.addFile(filename, result)\n    }\n  }\n\n  public getModuleDirs(filenames: string[]): string[] {\n    return uniq(\n      compact(\n        filenames.map((filename) => {\n          return this.moduleDirectoryLocator.getModuleDir(filename)\n        }),\n      ),\n    )\n  }\n}\n","import type IAlertAggregator from './types/IAlertAggregator'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPluginOptions from './types/IPluginOptions'\nimport validate from 'spdx-expression-validate'\n\n/**\n * Identifies license type based on package.json and selects\n * preferred license type if multiple are found\n */\nexport default class LicenseIdentifier {\n  constructor(\n    private alertAggregator: IAlertAggregator,\n    private readonly preferredLicenses: string[] = [],\n  ) {}\n\n  public identifyLicense(\n    meta: IPackageJson,\n    options: Pick<\n      IPluginOptions,\n      'licenseOverrides' | 'unacceptableLicenseTest'\n    >,\n  ): string | null {\n    const id = `${meta.name}@${meta.version}`\n    let license: string\n\n    if (options.licenseOverrides[id]) {\n      license = options.licenseOverrides[id]\n    }\n    else if (typeof meta.license === 'object') {\n      license = meta.license.type\n    }\n    else if (meta.license) {\n      license = meta.license\n    }\n    else if (Array.isArray(meta.licenses) && meta.licenses.length > 0) {\n      // handle deprecated `licenses` field\n      license\n        = this.findPreferredLicense(meta.licenses.map(l => l.type))\n          || meta.licenses[0].type\n    }\n    else if (typeof meta.licenses === 'string') {\n      // handle invalid string values for deprecated `licenses` field\n      // unfortunately, these are rather common\n      license = meta.licenses\n    }\n\n    if (!license) {\n      this.alertAggregator.addError(`Could not find license info for ${id}`)\n    }\n    else if (options.unacceptableLicenseTest(license)) {\n      this.alertAggregator.addError(\n        `Found unacceptable license \"${license}\" for ${id}`,\n      )\n    }\n    else if (!validate(license)) {\n      this.alertAggregator.addError(\n        `License \"${license}\" for ${id} is not a valid SPDX expression!`,\n      )\n    }\n\n    return license || null\n  }\n\n  private findPreferredLicense(licenseTypes: string[]): string | null {\n    for (const preferredLicenseType of this.preferredLicenses) {\n      for (const licenseType of licenseTypes) {\n        if (preferredLicenseType === licenseType) {\n          return preferredLicenseType\n        }\n      }\n    }\n    return null\n  }\n}\n","import type IAlertAggregator from './types/IAlertAggregator'\nimport type IDefaultLicenseTextProvider from './types/IDefaultLicenseTextProvider'\nimport type IFileSystem from './types/IFileSystem'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPluginOptions from './types/IPluginOptions'\nimport { join } from 'node:path'\nimport DefaultLicenseTextProvider from './DefaultLicenseTextProvider'\n\n/**\n * Reads license text from license file.\n *\n * If no license file is found, default license texts can automatically\n * be added (either retrieved from spdx github repository or read from\n * a directory).\n */\nexport default class LicenseTextReader {\n  constructor(\n    private alertAggregator: IAlertAggregator,\n    private fileSystem: IFileSystem,\n    private options: Pick<IPluginOptions, 'replenishDefaultLicenseTexts'>,\n    private defaultLicenseReader: IDefaultLicenseTextProvider = new DefaultLicenseTextProvider(),\n  ) {}\n\n  public async readLicenseText(\n    meta: IPackageJson,\n    license: string,\n    moduleDir: string,\n  ): Promise<string | null> {\n    const id = `${meta.name}@${meta.version}`\n\n    if (!license) {\n      return null\n    }\n\n    if (license.indexOf('SEE LICENSE IN ') === 0) {\n      const filename = license.split(' ')[3]\n      try {\n        return this.readFile(moduleDir, filename)\n      }\n      // eslint-disable-next-line unused-imports/no-unused-vars\n      catch (e) {\n        this.alertAggregator.addError(\n          `could not find file specified in package.json license field of ${id}`,\n        )\n      }\n    }\n\n    const pathsInModuleDir = this.fileSystem.listPaths(moduleDir)\n    const licenseFilename = this.getLicenseFilename(pathsInModuleDir)\n\n    if (licenseFilename !== null) {\n      return this.readFile(moduleDir, licenseFilename)\n    }\n\n    if (this.options.replenishDefaultLicenseTexts) {\n      return await this.getDefaultLicenseText(license)\n    }\n\n    return null\n  }\n\n  public getLicenseFilename(paths: string[]): string | null {\n    for (const path of paths) {\n      if (/^licen[cs]e/i.test(path)) {\n        return path\n      }\n    }\n\n    return null\n  }\n\n  public readFile(directory: string, filename: string): string {\n    return this.fileSystem\n      .readFile(join(directory, filename))\n      .replace(/\\r\\n/g, '\\n')\n  }\n\n  public async getDefaultLicenseText(license: string): Promise<string> {\n    return await this.defaultLicenseReader.retrieveLicenseText(license)\n  }\n}\n","import needle from 'needle'\n\nexport async function fetch(url: string): Promise<string | null> {\n  const res = await needle('get', url)\n  return res.statusCode === 200 ? res.body : null\n}\n\nexport const REPO_URL\n  = 'https://raw.githubusercontent.com/spdx/license-list-data'\n\ninterface IDefaultLicenseTextCache {\n  [license: string]: string | null\n}\n\nexport default class DefaultLicenseTextProvider {\n  private cache: IDefaultLicenseTextCache = {}\n\n  constructor(private request: typeof fetch = fetch) {}\n\n  public async retrieveLicenseText(license: string): Promise<string | null> {\n    if (!this.cache[license]) {\n      const res = await this.request(`${REPO_URL}/main/text/${license}.txt`)\n      this.cache[license] = res\n    }\n\n    return this.cache[license] || null\n  }\n}\n","import type IFileSystem from './types/IFileSystem'\nimport { join } from 'node:path'\n\n/**\n * Reads notice text from notice file.\n *\n * If no notice file is found returns null.\n */\nexport default class NoticeTextReader {\n  constructor(private fileSystem: IFileSystem) {}\n\n  public async readNoticeText(moduleDir: string): Promise<string | null> {\n    const noticeFilename = this.fileSystem\n      .listPaths(moduleDir)\n      .find(filename => /^notice/i.test(filename))\n\n    if (!noticeFilename) {\n      return null\n    }\n\n    const noticeFilePath = join(moduleDir, noticeFilename)\n    return this.fileSystem.readFile(noticeFilePath).replace(/\\r\\n/g, '\\n')\n  }\n}\n","import type IAlertAggregator from './types/IAlertAggregator'\nimport type IFileSystem from './types/IFileSystem'\nimport type ILicenseIdentifier from './types/ILicenseIdentifier'\nimport type ILicenseMetaAggregator from './types/ILicenseMetaAggregator'\nimport type ILicenseTextReader from './types/ILicenseTextReader'\nimport type INoticeTextReader from './types/INoticeTextReader'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPackageJsonReader from './types/IPackageJsonReader'\nimport type IPackageLicenseMeta from './types/IPackageLicenseMeta'\nimport type IPluginOptions from './types/IPluginOptions'\nimport LicenseIdentifier from './LicenseIdentifier'\nimport LicenseTextReader from './LicenseTextReader'\nimport NoticeTextReader from './NoticeTextReader'\n\nexport default class LicenseMetaAggregator implements ILicenseMetaAggregator {\n  constructor(\n    fileSystem: IFileSystem,\n    alertAggregator: IAlertAggregator,\n    private options: IPluginOptions,\n    private packageJsonReader: IPackageJsonReader,\n    private licenseIdentifier: ILicenseIdentifier = new LicenseIdentifier(\n      alertAggregator,\n    ),\n    private licenseTextReader: ILicenseTextReader = new LicenseTextReader(\n      alertAggregator,\n      fileSystem,\n      options,\n    ),\n    private noticeTextReader: INoticeTextReader = new NoticeTextReader(\n      fileSystem,\n    ),\n  ) { }\n\n  private getNpmTarballUrl(\n    pkgName: string,\n    pkgVersion: string,\n  ) {\n    const scopelessName = pkgName[0] !== '@' ? pkgName : pkgName.split('/')[1]\n    const plusPos = pkgVersion.indexOf('+')\n    const version = plusPos === -1 ? pkgVersion : pkgVersion.substring(0, plusPos)\n    return `https://registry.npmjs.org/${pkgName}/-/${scopelessName}-${version}.tgz`\n  }\n\n  public async aggregateMeta(\n    moduleDirs: string[],\n  ): Promise<IPackageLicenseMeta[]> {\n    const packageSet = new Set()\n    const result: IPackageLicenseMeta[] = []\n    const sortedModuleDirs = moduleDirs.sort((a, b) =>\n      this.packageJsonReader\n        .readPackageJson(a)\n        .name\n        .localeCompare(this.packageJsonReader.readPackageJson(b).name),\n    )\n\n    for (const moduleDir of sortedModuleDirs) {\n      const meta = this.packageJsonReader.readPackageJson(moduleDir)\n      const packageIdentifier = `${meta.name}@${meta.version}`\n\n      if (packageSet.has(packageIdentifier)) {\n        continue\n      }\n\n      if (this.options.excludedPackageTest(meta.name, meta.version)) {\n        continue\n      }\n\n      packageSet.add(packageIdentifier)\n      const license = this.licenseIdentifier.identifyLicense(meta, this.options)\n      const licenseText = await this.licenseTextReader.readLicenseText(\n        meta,\n        license,\n        moduleDir,\n      )\n      const noticeText = this.options.includeNoticeText ? await this.noticeTextReader.readNoticeText(moduleDir) : undefined\n      result.push({\n        name: meta.name,\n        version: meta.version,\n        author: this.getAuthor(meta),\n        repository: this.getRepository(meta),\n        source: this.getNpmTarballUrl(meta.name, meta.version),\n        license,\n        licenseText,\n        ...(noticeText ? { noticeText } : {}),\n      })\n    }\n\n    return result\n  }\n\n  public getAuthor(meta: Pick<IPackageJson, 'author'>): string {\n    return typeof meta.author === 'object'\n      ? `${meta.author.name}${meta.author.email ? ` <${meta.author.email}>` : ''\n      }${meta.author.url ? ` (${meta.author.url})` : ''}`\n      : meta.author\n  }\n\n  public getRepository(meta: Pick<IPackageJson, 'repository'>): string {\n    if (meta.repository && meta.repository.url) {\n      return meta.repository.url\n    }\n    else if (typeof meta.repository === 'string') {\n      return meta.repository\n    }\n\n    return null\n  }\n}\n","import type IFileSystem from './types/IFileSystem'\nimport type IModuleDirectoryLocator from './types/IModuleDirectoryLocator'\nimport type IPackageJsonReader from './types/IPackageJsonReader'\nimport { resolve, sep } from 'node:path'\n\n/**\n * Locates module directories for given filenames by searching\n * the directory tree for package.json files.\n */\n\nexport default class ModuleDirectoryLocator implements IModuleDirectoryLocator {\n  constructor(\n    private fileSystem: IFileSystem,\n    private buildRoot: string,\n    private packageJsonReader: IPackageJsonReader,\n  ) {}\n\n  public getModuleDir(filename: string): string | null {\n    const moduleDir = filename.substring(0, filename.lastIndexOf(sep))\n    return this.checkModuleDir(moduleDir)\n  }\n\n  private checkModuleDir(moduleDir: string): string | null {\n    let dirWithVersion: string | null = null\n    let dirWithLicense: string | null = null\n    let prevModuleDir: string | null = null\n\n    do {\n      if (this.fileSystem.pathExists(`${moduleDir}${sep}package.json`)) {\n        const packageMeta = this.packageJsonReader.readPackageJson(moduleDir)\n\n        if (\n          packageMeta.name !== undefined\n          && packageMeta.version !== undefined\n        ) {\n          dirWithVersion = moduleDir\n\n          if (\n            packageMeta.license !== undefined\n            || packageMeta.licenses !== undefined\n          ) {\n            dirWithLicense = moduleDir\n          }\n        }\n      }\n\n      prevModuleDir = moduleDir\n      moduleDir = resolve(`${moduleDir}${sep}..${sep}`)\n    } while (\n      !dirWithLicense\n      && moduleDir !== prevModuleDir\n      && moduleDir !== this.buildRoot\n    )\n\n    return dirWithLicense || dirWithVersion\n  }\n}\n","import type IAlertAggregator from './types/IAlertAggregator'\nimport type IPluginOptions from './types/IPluginOptions'\nimport validate from 'spdx-expression-validate'\nimport defaultOptions from './defaultOptions'\n\nexport default class OptionsProvider {\n  constructor(private readonly alertAggregator: IAlertAggregator) {}\n\n  public getOptions(inputOptions: Partial<IPluginOptions>): IPluginOptions {\n    this.validateOptions(inputOptions)\n    const options = { ...defaultOptions, ...inputOptions }\n    return options\n  }\n\n  public validateOptions(inputOptions: Partial<IPluginOptions>) {\n    if (inputOptions.additionalFiles) {\n      for (const fileName of Object.keys(inputOptions.additionalFiles)) {\n        if (typeof inputOptions.additionalFiles[fileName] !== 'function') {\n          this.alertAggregator.addError(\n            `Invalid additionalFiles option: Value for key \"${fileName}\" is not a function!`,\n          )\n        }\n      }\n    }\n\n    if (inputOptions.licenseOverrides) {\n      for (const packageVersion of Object.keys(inputOptions.licenseOverrides)) {\n        if (!validate(inputOptions.licenseOverrides[packageVersion])) {\n          this.alertAggregator.addError(\n            `Invalid licenseOverrides option: \"${inputOptions.licenseOverrides[packageVersion]}\" is not a valid SPDX expression!`,\n          )\n        }\n      }\n    }\n\n    if (\n      inputOptions.replenishDefaultLicenseTexts\n      && typeof inputOptions.replenishDefaultLicenseTexts !== 'boolean'\n    ) {\n      this.alertAggregator.addError(\n        `Invalid replenishDefaultLicenseTexts option: Not a boolean!`,\n      )\n    }\n\n    if (\n      inputOptions.includePackages\n      && typeof inputOptions.includePackages !== 'function'\n    ) {\n      this.alertAggregator.addError(\n        `Invalid includePackages option: Not a function!`,\n      )\n    }\n  }\n}\n","import type IPluginOptions from './types/IPluginOptions'\n\nconst defaultOptions: IPluginOptions = {\n  additionalFiles: {},\n  licenseOverrides: {},\n  outputFilename: 'oss-licenses.json',\n  replenishDefaultLicenseTexts: false,\n  includeNoticeText: false,\n  unacceptableLicenseTest: () => false,\n  excludedPackageTest: () => false,\n  includePackages: () => [],\n}\n\nexport default defaultOptions\n","import type IFileSystem from './types/IFileSystem'\nimport type IPackageJson from './types/IPackageJson'\nimport { join } from 'node:path'\n\ninterface IPackageJsonCache {\n  [moduleDir: string]: IPackageJson\n}\n\nexport default class PackageJsonReader {\n  private cache: IPackageJsonCache = {}\n\n  constructor(private fileSystem: IFileSystem) {}\n\n  public readPackageJson(moduleDir: string): IPackageJson {\n    if (!this.cache[moduleDir]) {\n      const path = join(moduleDir, 'package.json')\n      const meta = JSON.parse(this.fileSystem.readFile(path))\n      this.cache[moduleDir] = meta\n    }\n\n    return this.cache[moduleDir]\n  }\n}\n","import type IAlertAggregator from './types/IAlertAggregator'\nimport webpack from 'webpack'\n\nconst WebpackError = webpack.WebpackError\n\nexport default class WebpackAlertAggregator implements IAlertAggregator {\n  private errors: string[] = []\n  private warnings: string[] = []\n\n  constructor(private readonly compilation: webpack.Compilation) {}\n\n  public addError(message: string) {\n    this.errors.push(message)\n  }\n\n  public addWarning(message: string) {\n    this.warnings.push(message)\n  }\n\n  public flushAlerts(prefix: string): void {\n    this.compilation.errors.push(\n      ...this.errors.map(e => new WebpackError(`${prefix}: ${e}`)),\n    )\n    this.errors = []\n    this.compilation.warnings.push(\n      ...this.warnings.map(w => new WebpackError(`${prefix}: ${w}`)),\n    )\n    this.warnings = []\n  }\n}\n","import type { Compilation } from 'webpack'\nimport type IAssetManager from './types/IAssetManager'\nimport webpack from 'webpack'\n\nconst sources = webpack.sources\n\nexport default class WebpackAssetManager implements IAssetManager {\n  constructor(private compilation: Compilation) {}\n\n  public addFile(filename: string, contents: string): void {\n    this.compilation.assets[filename] = new sources.RawSource(contents)\n  }\n}\n","import type * as webpack from 'webpack'\nimport type IWebpackChunkModule from './types/IWebpackChunkModule'\n\nexport type Compilation = Partial<\n  webpack.Compilation & {\n    chunkGraph: {\n      getChunkModulesIterable: (chunk: Chunk) => IWebpackChunkModule[]\n      getChunkEntryModulesIterable: (chunk: Chunk) => IWebpackChunkModule[]\n    }\n  }\n>\n\ntype Chunk = Partial<\n  Pick<\n    webpack.Chunk & {\n      forEachModule?: (callback: (module: IWebpackChunkModule) => void) => void\n      modules?: IWebpackChunkModule[]\n    },\n    'entryModule' | 'forEachModule' | 'modules' | 'modulesIterable'\n  >\n>\n\nexport default class WebpackChunkModuleIterator {\n  public iterateModules(\n    compilation: Compilation,\n    chunk: Chunk,\n    callback: (module: IWebpackChunkModule) => void,\n  ): void {\n    if (typeof compilation.chunkGraph !== 'undefined') {\n      for (const module of compilation.chunkGraph.getChunkModulesIterable(\n        chunk,\n      )) {\n        callback(module)\n      }\n    }\n    else if (typeof chunk.modulesIterable !== 'undefined') {\n      for (const module of chunk.modulesIterable) {\n        // @ts-expect-error module not assignable to IWebpackChunkModule\n        callback(module)\n      }\n    }\n    else if (typeof chunk.forEachModule === 'function') {\n      chunk.forEachModule(callback)\n    }\n    else if (Array.isArray(chunk.modules)) {\n      chunk.modules.forEach(module => callback(module))\n    }\n\n    if (typeof compilation.chunkGraph !== 'undefined') {\n      for (const module of compilation.chunkGraph.getChunkEntryModulesIterable(\n        chunk,\n      )) {\n        callback(module)\n      }\n    }\n    else if (chunk.entryModule) {\n      // @ts-expect-error chunk.entryModule not assignable to IWebpackChunkModule\n      callback(chunk.entryModule)\n    }\n  }\n}\n","import type IWebpackChunkModule from './types/IWebpackChunkModule'\n\nexport default class WebpackModuleFileIterator {\n  public iterateFiles(\n    {\n      resource,\n      rootModule,\n      fileDependencies,\n      dependencies,\n    }: IWebpackChunkModule,\n    callback: (filename: string) => void,\n  ): void {\n    if (resource) {\n      callback(resource)\n    }\n    else if (rootModule?.resource) {\n      callback(rootModule.resource)\n    }\n\n    if (fileDependencies) {\n      fileDependencies.forEach(dep => callback(dep))\n    }\n\n    if (dependencies) {\n      dependencies.forEach(({ originModule, _parentModule }) => {\n        if (originModule?.resource) {\n          callback(originModule.resource)\n        }\n        if (_parentModule?.resource) {\n          callback(_parentModule.resource)\n        }\n      })\n    }\n  }\n}\n","import type * as webpack from 'webpack'\nimport type { Compilation } from './WebpackChunkModuleIterator'\nimport WebpackChunkModuleIterator from './WebpackChunkModuleIterator'\nimport WebpackModuleFileIterator from './WebpackModuleFileIterator'\n\nexport default class WebpackChunkIterator {\n  constructor(\n    private moduleIterator: WebpackChunkModuleIterator = new WebpackChunkModuleIterator(),\n    private fileIterator: WebpackModuleFileIterator = new WebpackModuleFileIterator(),\n  ) {}\n\n  public iterateChunks(\n    compilation: webpack.Compilation,\n    chunks: Set<webpack.Chunk>,\n  ): string[] {\n    const filenames = []\n\n    for (const chunk of chunks) {\n      this.moduleIterator.iterateModules(\n        compilation as Compilation,\n        chunk,\n        (module) => {\n          this.fileIterator.iterateFiles(module, (filename) => {\n            filenames.push(filename)\n          })\n        },\n      )\n    }\n\n    return filenames\n  }\n}\n","import type IFileSystem from './types/IFileSystem'\n\nexport default class WebpackFileSystem implements IFileSystem {\n  constructor(private fs: any) {}\n\n  public pathExists(filename: string): boolean {\n    try {\n      this.fs.statSync(filename)\n      return true\n    }\n    // eslint-disable-next-line unused-imports/no-unused-vars\n    catch (e) {\n      return false\n    }\n  }\n\n  public readFile(filename: string): string {\n    return this.fs.readFileSync(filename).toString('utf8')\n  }\n\n  public listPaths(dir: string): string[] {\n    return this.fs.readdirSync(dir)\n  }\n}\n","import WebpackLicensePlugin from './WebpackLicensePlugin'\n\nexport default WebpackLicensePlugin\n"]}